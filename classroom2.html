<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<div id="ThreeJS">
		</div>

	<script src="js/Three.js"></script>
	<script src="js/Detector.js"></script>
	<script src="js/Stats.js"></script>
	<script src="js/OrbitControls.js"></script>
	<script src="js/THREEx.KeyboardState.js"></script>
	<script src="js/THREEx.FullScreen.js"></script>
	<script src="js/THREEx.WindowResize.js"></script>
		<!--<script src="three.js"></script>-->
		<script>

		/* CONSTANTS */ 
		const SEATSIZE = 50;
		const SEATCOLOR = 0x0f4094;
		const SEATFLOAT = 10;
		const TABLE_HEIGHT = (SEATSIZE * 1.4);
		const TABLE_LENGTH = (SEATSIZE * 4.5);
		const TABLE_WIDTH = (SEATSIZE * 1.5); 
		var seatCounter = 0;
		var cube;
		
		/*
	Three.js "tutorials by example"
	Author: Lee Stemkoski
	Date: July 2013 (three.js v59dev)
 */
	
	//////////	
	// MAIN //
	//////////
	// standard global variables
	var container, scene, camera, renderer, controls, stats;
	var keyboard = new THREEx.KeyboardState();
	var clock = new THREE.Clock();

	// custom global variables
		// build a class for seats rather than trying to build new things
	var Seat = class Seat {
		// wrapper for name
		constructor(xpos,ypos,zpos) {
			var seatGeometry = new THREE.CubeGeometry(SEATSIZE, SEATSIZE, SEATSIZE, 1, 1, 1 );
			var seatMaterial = getSeatMaterial();
			//this.name = "seat"+seatCounter;
			//var namestring = "seat"+seatCounter; 
			this.seat = new THREE.Mesh(seatGeometry, seatMaterial);
			this.seat.position.set(xpos, ((SEATSIZE / 2) + SEATFLOAT), zpos);
			scene.add(this.seat);
			this.status = 0;
			seatCounter++;
		}

		getStatus() {
			return this.status;
		}

		change() {
			if (this.status == 0) {
				this.seat.material = new THREE.MeshPhongMaterial( { color: SEATCOLOR, transparent: true, opacity: 0.75 });
				this.seat.position.y = this.seat.position.y - SEATFLOAT;
				this.status = 1;
			}
			else
			{
				this.seat.material = new THREE.MeshPhongMaterial( { color: SEATCOLOR, transparent: false, opacity: 0.99 });
				this.seat.position.y = this.seat.position.y + SEATFLOAT;
				this.status = 0;
			}
			
		}
	}
	var Table = class Table {
		// wrapper for name
		constructor(xpos,zpos) {
			var tableGeometry = new THREE.CubeGeometry(TABLE_LENGTH, TABLE_HEIGHT, TABLE_WIDTH, 1, 1, 1 );
			var tableMaterial = getTableMaterial();
			//this.name = "seat"+seatCounter;
			//var namestring = "seat"+seatCounter; 
			this.table = new THREE.Mesh(tableGeometry, tableMaterial);
			this.table.position.set(xpos, ((TABLE_HEIGHT / 2)), zpos);
			scene.add(this.table);
			this.status = 0;
		}
	}

	// initialization
	init();
	// animation loop / game loop
	animate();
	///////////////
	// FUNCTIONS //
	///////////////
				
	function init() 
	{
		///////////
		// SCENE //
		///////////
		scene = new THREE.Scene();
		////////////
		// CAMERA //
		////////////
		
		// set the view size in pixels (custom or according to window size)
		// var SCREEN_WIDTH = 400, SCREEN_HEIGHT = 300;
		var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;	
		// camera attributes
		var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
		// set up camera
		camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
		// add the camera to the scene
		scene.add(camera);
		// the camera defaults to position (0,0,0)
		// 	so pull it back (z = 400) and up (y = 100) and set the angle towards the scene origin
		camera.position.set(200,450,-400);
		camera.lookAt(scene.position);	
		
		//////////////
		// RENDERER //
		//////////////
		
		// create and start the renderer; choose antialias setting.
		if ( Detector.webgl )
			renderer = new THREE.WebGLRenderer( {antialias:true} );
		else
			renderer = new THREE.CanvasRenderer(); 
		
		renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
		
		// attach div element to variable to contain the renderer
		container = document.getElementById( 'ThreeJS' );
		// alternatively: to create the div at runtime, use:
		//   container = document.createElement( 'div' );
		//    document.body.appendChild( container );
		
		// attach renderer to the container div
		container.appendChild( renderer.domElement );
		
		////////////
		// EVENTS //
		////////////
		// automatically resize renderer
		THREEx.WindowResize(renderer, camera);
		// toggle full-screen on given key press
		THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
		
		//////////////
		// CONTROLS //
		//////////////
		// move mouse and: left   click to rotate, 
		//                 middle click to zoom, 
		//                 right  click to pan
		controls = new THREE.OrbitControls( camera, renderer.domElement );
		
		///////////
		// LIGHT //
		///////////
		
		// create a light
		var light = new THREE.PointLight(0xffffff);
		light.position.set(0,250,0);
		scene.add(light);
		var ambientLight = new THREE.AmbientLight(0x111111);
		// scene.add(ambientLight);
		
		//////////////
		// GEOMETRY //
		//////////////
			
		// most objects displayed are a "mesh":
		//  a collection of points ("geometry") and
		//  a set of surface parameters ("material")	
		// Sphere parameters: radius, segments along width, segments along height
		// var sphereGeometry = new THREE.SphereGeometry( 50, 32, 16 ); 
		// use a "lambert" material rather than "basic" for realistic lighting.
		//   (don't forget to add (at least one) light!)
		// var sphereMaterial = new THREE.MeshLambertMaterial( {color: 0x8888ff} ); 
		// var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
		// sphere.position.set(100, 50, -50);
		// scene.add(sphere);
		
		// Create an array of materials to be used in a cube, one for each side
		
		// Cube parameters: width (x), height (y), depth (z), 
		//        (optional) segments along x, segments along y, segments along z
		var cubeGeometry = new THREE.CubeGeometry(50, 50, 50, 1, 1, 1 );
		// using THREE.MeshFaceMaterial() in the constructor below
		//   causes the mesh to use the materials stored in the geometry
		var blackCubeMaterials = new THREE.MeshFaceMaterial(solidColorArray(0x0f4094));
		//cube = new THREE.Mesh( cubeGeometry, cubeMaterials );
		cube = new THREE.Mesh(cubeGeometry, blackCubeMaterials);
		cube.position.set(-100, 35, -50);
		//scene.add( cube );	

		var seatName = "Testing"; 
		//this[seatName] = new Seat(-100,150,100);
		
		var table1 = new Table(TABLE_LENGTH*-0.5,TABLE_LENGTH*0.5+(TABLE_WIDTH/2));
		var table2 = new Table(TABLE_LENGTH*0.5,TABLE_LENGTH*0.5+(TABLE_WIDTH/2));
		var table3 = new Table(TABLE_LENGTH-(TABLE_WIDTH/2), 0);
		table3.table.rotateY(Math.PI/2);
		var table4 = new Table(TABLE_LENGTH*0.5, TABLE_LENGTH*-0.5-(TABLE_WIDTH/2));
		var table5 = new Table(TABLE_LENGTH*-0.5, TABLE_LENGTH*-0.5-(TABLE_WIDTH/2));
		

		// SEATS - outside tables  
		// - table 1 - 
		makeNewSeat(TABLE_LENGTH*-0.5+SEATSIZE, TABLE_LENGTH*0.5+(TABLE_WIDTH/2)+((TABLE_WIDTH+SEATSIZE)/2)+SEATSIZE/3);
		makeNewSeat(TABLE_LENGTH*-0.5-SEATSIZE, TABLE_LENGTH*0.5+(TABLE_WIDTH/2)+((TABLE_WIDTH+SEATSIZE)/2)+SEATSIZE/3);
		// - table 2 - 
		makeNewSeat(TABLE_LENGTH*0.5-SEATSIZE, TABLE_LENGTH*0.5+(TABLE_WIDTH/2)+((TABLE_WIDTH+SEATSIZE)/2)+SEATSIZE/3)
		makeNewSeat(TABLE_LENGTH*0.5+SEATSIZE, TABLE_LENGTH*0.5+(TABLE_WIDTH/2)+((TABLE_WIDTH+SEATSIZE)/2)+SEATSIZE/3)
		// - table 3 - 
		makeNewSeat(TABLE_LENGTH + SEATSIZE/2 + SEATSIZE/3, TABLE_LENGTH*0.5-SEATSIZE);
		makeNewSeat(TABLE_LENGTH + SEATSIZE/2 + SEATSIZE/3, TABLE_LENGTH*-0.5+SEATSIZE);
		// - table 4 - 
		makeNewSeat(TABLE_LENGTH*0.5+SEATSIZE, TABLE_LENGTH*-0.5-(TABLE_WIDTH/2)-((TABLE_WIDTH+SEATSIZE)/2)-SEATSIZE/3);
		makeNewSeat(TABLE_LENGTH*0.5-SEATSIZE, TABLE_LENGTH*-0.5-(TABLE_WIDTH/2)-((TABLE_WIDTH+SEATSIZE)/2)-SEATSIZE/3);
		// - table 5 - 
		makeNewSeat(TABLE_LENGTH*-0.5+SEATSIZE, TABLE_LENGTH*-0.5-(TABLE_WIDTH/2)-((TABLE_WIDTH+SEATSIZE)/2)-SEATSIZE/3);
		makeNewSeat(TABLE_LENGTH*-0.5-SEATSIZE, TABLE_LENGTH*-0.5-(TABLE_WIDTH/2)-((TABLE_WIDTH+SEATSIZE)/2)-SEATSIZE/3);
		
		// SEATS - inside tables 
		// - table 1 - 
		makeNewSeat(TABLE_LENGTH*-0.5+SEATSIZE/2, TABLE_LENGTH*0.5+(TABLE_WIDTH/2)-((TABLE_WIDTH+SEATSIZE)/2)-SEATSIZE/3);
		// - table 2 - 
		makeNewSeat(TABLE_LENGTH*0.5-SEATSIZE/2, TABLE_LENGTH*0.5+(TABLE_WIDTH/2)-((TABLE_WIDTH+SEATSIZE)/2)-SEATSIZE/3);
		// - table 3 - 
		makeNewSeat(TABLE_LENGTH-(TABLE_WIDTH/2)-TABLE_WIDTH/2-SEATSIZE/2-SEATSIZE/3, 0);
		// - table 4 - 
		makeNewSeat(TABLE_LENGTH*0.5-SEATSIZE/2, TABLE_LENGTH*-0.5-(TABLE_WIDTH/2)+((TABLE_WIDTH+SEATSIZE)/2)+SEATSIZE/3);
		// - table 5 - 
		makeNewSeat(TABLE_LENGTH*-0.5+SEATSIZE/2, TABLE_LENGTH*-0.5-(TABLE_WIDTH/2)+((TABLE_WIDTH+SEATSIZE)/2)+SEATSIZE/3);

		// 0 for open, 1 for taken
		// cube.status = 0;

		// cube.change = function() {
		// 	if (cube.status == 0) {
		// 		cube.material = new THREE.MeshPhongMaterial( { color: CUBECOLOR, transparent: true, opacity: 0.75 });
		// 		cube.position.y = 25
		// 		cube.status = 1;
		// 	}
		// 	else
		// 	{
		// 		cube.material = new THREE.MeshPhongMaterial( { color: CUBECOLOR, transparent: false, opacity: 0.99 });
		// 		cube.position.y = 35;
		// 		cube.status = 0;
		// 	}
			
		// }


		// var darkTranslucentMaterial = new THREE.MeshPhongMaterial( { color: 0x333333, transparent: true, opacity: 0.75 } );
		// second = new THREE.Mesh(cubeGeometry, darkTranslucentMaterial);
		// second.position.set(-100, 25, -100);
		// scene.add( second );
		
		///////////
		// FLOOR //
		///////////
		
		// note: 4x4 checkboard pattern scaled so that each square is 25 by 25 pixels.
		var floorTexture = new THREE.ImageUtils.loadTexture( 'img/carpet.jpg' );
		floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
		floorTexture.repeat.set( 10, 10 );
		// DoubleSide: render texture on both sides of mesh
		var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
		var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 1, 1);
		var floor = new THREE.Mesh(floorGeometry, floorMaterial);
		floor.position.y = -0.5;
		floor.rotation.x = Math.PI / 2;
		scene.add(floor);
		
		/////////
		// SKY //
		/////////
		
		// recommend either a skybox or fog effect (can't use both at the same time) 
		// without one of these, the scene's background color is determined by webpage background
		// make sure the camera's "far" value is large enough so that it will render the skyBox!
		var skyBoxGeometry = new THREE.CubeGeometry( 10000, 10000, 10000 );
		// BackSide: render faces from inside of the cube, instead of from outside (default).
		var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x9999ff, side: THREE.BackSide } );
		var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
		// scene.add(skyBox);
		
		// fog must be added to scene before first render
		scene.fog = new THREE.FogExp2( 0x9999ff, 0.00025 );
	}
	function animate() 
	{
	    requestAnimationFrame( animate );
			render();		
			update();
	}
	function update()
	{
		// delta = change in time since last call (in seconds)
		var delta = clock.getDelta(); 
		// functionality provided by THREEx.KeyboardState.js
		if ( keyboard.pressed("1") )
			document.getElementById('message').innerHTML = ' Have a nice day! - 1';	
		if ( keyboard.pressed("2") )
			document.getElementById('message').innerHTML = ' Have a nice day! - 2 ';	
			
		controls.update();
		//stats.update();
	}
	function render() 
	{	
		renderer.render( scene, camera );
	}
	function getSeatMaterial() {
		return (new THREE.MeshLambertMaterial( { color: 0x333333, transparent: true, opacity: 0.75 } ));
	}
	function getTableMaterial() {
		return (new THREE.MeshLambertMaterial( { color: 0x889922, transparent: true, opacity: 0.75 } ));
	}
	function solidColorArray(colorChoice)
	{
		var colorMaterialArray = [];
		for (var i = 0; i < 6; i++) {
			colorMaterialArray.push(new THREE.MeshLambertMaterial({ color: colorChoice }) );
		}
		return colorMaterialArray;
	}
	function makeNewSeat(xpos,zpos) {
		this[("seat"+seatCounter)] = new Seat(xpos,(SEATSIZE/2),zpos);
	}
	



	// function newSeat(xpos, ypos, zpos) {
	// 	var seatGeometry = new THREE.CubeGeometry(50, 50, 50, 1, 1, 1 );
	// 	var seatMaterial = getSeatMaterial();
	// 	var namestring = "seat"+seatCounter; 
	// 	this[namestring] = new THREE.Mesh(seatGeometry, seatMaterial);
	// 	this[namestring].position.set(xpos, ypos, zpos);
	// 	scene.add(this[namestring]);
	// 	seatCounter++;
	// }

		// order to add materials: x+,x-,y+,y-,z+,z-
		
			// var scene = new THREE.Scene();
			// var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			// var renderer = new THREE.WebGLRenderer();
			// renderer.setSize( window.innerWidth, window.innerHeight );
			// document.body.appendChild( renderer.domElement );

			// var geometry = new THREE.BoxGeometry( 1, 1, 1 );
			// var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
			// var cube = new THREE.Mesh( geometry, material );
			// scene.add( cube );

			// camera.position.z = 5;

			// var render = function () {
			// 	requestAnimationFrame( render );

			// 	cube.rotation.x += 0.01;
			// 	cube.rotation.y += 0.01;

			// 	renderer.render(scene, camera);
			// };

			// render();


			// CUBE MATERIALS FACES //
			// var cubeMaterialArray = [];
			// order to add materials: x+,x-,y+,y-,z+,z-
			// cubeMaterialArray.push( new THREE.MeshBasicMaterial( { color: 0xff3333 } ) );
			// cubeMaterialArray.push( new THREE.MeshBasicMaterial( { color: 0xff8800 } ) );
			// cubeMaterialArray.push( new THREE.MeshBasicMaterial( { color: 0xffff33 } ) );
			// cubeMaterialArray.push( new THREE.MeshBasicMaterial( { color: 0x33ff33 } ) );
			// cubeMaterialArray.push( new THREE.MeshBasicMaterial( { color: 0x3333ff } ) );
			// cubeMaterialArray.push( new THREE.MeshBasicMaterial( { color: 0x8833ff } ) );
			// var cubeMaterials = new THREE.MeshFaceMaterial( cubeMaterialArray );


		</script>
	</body>
</html>